<!DOCTYPE html>
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Introduction to Computer Graphics, Section 5.2 -- Building Objects</title>
<link type="text/css" rel="stylesheet" href="../resource/graphicstext.css">
</head>
<body>
<div class="page">
<div align="right">
<small>
        [  <a href="s1.html">Previous Section</a> |
           <a href="s3.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
	    <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" cellpadding="5" border="2">
<tr>
<td>
<div align="center">
<b>Subsections</b>
<hr>
<small><a href="#threejs.2.1">Indexed Face Sets</a>
<br>
<a href="#threejs.2.2">Curves and Surfaces</a>
<br>
<a href="#threejs.2.3">Textures</a>
<br>
<a href="#threejs.2.4">Transforms</a>
<br>
<a href="#threejs.2.5">Loading JSON Models</a>
<br>
</small>
</div>
</td>
</tr>
</table>
<div class="content section">
<h3 class="section_title">Section 5.2</h3>
<h2 class="section_title">Building Objects</h2>
<hr class="break">


<p class="firstpar">In <i>three.js</i>, a visible object is constructed from a
geometry and a material.  We have seen how to create simple
geometries that are suitable for point and line primitives,
and we have encountered a variety of standard mesh geometries
such as <span class="classname">THREE.CylinderGeometry</span> and
<span class="classname">THREE.IcosahedronGeometry</span>.  In this
section, we will see how to create new mesh geometries from
scratch.  We'll also look at some of the other support
that <i>three.js</i> provides for working with objects and
materials.</p>


<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="threejs.2.1">5.2.1&nbsp;&nbsp;Indexed Face Sets</h3>


<p>A mesh in <i>three.js</i> is what we called an <span class="word" data-term="indexed face set" data-definition=" (IFS). A data structure that represents a polyhedron or polygonal
mesh.  The data structure includes a numbered list of vertices and a list of faces.  A face
is specified by listing the indices of the vertices of the face; that is, a face is given as 
a list of numbers where each number is an index into the list of vertices." title="Click for a definition of indexed face set.">indexed face set</span> in
<a href="../c3/s4.html#gl1geom.4.1">Subsection&nbsp;3.4.1</a>.  In a <i>three.js</i> mesh, all the polygons are triangles.
A geometry in <i>three.js</i> is an object of type <span class="classname">THREE.Geometry</span>.
Any geometry object contains an array of vertices, represented as objects of type
<span class="classname">THREE.Vector3</span>.  For a mesh geometry, it also contains an
array of faces, represented as objects of type <span class="classname">THREE.Face3</span>.  Each object
of type <span class="classname">Face3</span> specifies one of the triangular faces of the
geometry.  The three vertices of the triangle are specified by three integers.  Each
integer is an index into the geometry's vertex array.  The three integers can
be specified as parameters to the <span class="classname">THREE.Face3</span> constructor.
For example,</p>


<pre>var f = new THREE.Face3( 0, 7, 2 );</pre>


<p class="noindent">The three indices are stored as properties <i>f.a</i>, <i>f.b</i>, and
<i>f.c</i> of the face object. As an example, let's see how to directly create a <i>three.js</i> geometry
for this pyramid:</p>


<p align="center">
<img src="pyramid-IFS.png" width="419" height="194" alt=""></p>


<p class="noindent">Note that the bottom face of the pyramid, which is a square, has to be
divided into two triangles in order for the pyramid to be represented as a mesh geometry.
If <i>pyramidGeom</i> is the geometry object for this pyramid, then
<i>pyramidGeom.vertices</i> is the vertex array, and <i>pyramidGeom.faces</i>
is the face array.  With that in mind, we can define:</p>



<pre>var pyramidGeom = new THREE.Geometry();

pyramidGeom.vertices = [  // array of Vector3 giving vertex coordinates
        new THREE.Vector3( 1, 0, 1 ),    // vertex number 0
        new THREE.Vector3( 1, 0, -1 ),   // vertex number 1
        new THREE.Vector3( -1, 0, -1 ),  // vertex number 2
        new THREE.Vector3( -1, 0, 1 ),   // vertex number 3
        new THREE.Vector3( 0, 1, 0 )     // vertex number 4
    ];
    
pyramidGeom.faces = [  // array of Face3 giving the triangular faces
        new THREE.Face3( 3, 2, 1 ),  // first half of the bottom face
        new THREE.Face3 3, 1, 0 ),   // second half of the bottom face
        new THREE.Face3( 3, 0, 4 ),  // remaining faces are the four sides
        new THREE.Face3( 0, 1, 4 ),
        new THREE.Face3( 1, 2, 4 ),
        new THREE.Face3( 2, 3, 4 )
    ];</pre>


<p class="noindent">Note that the order of the vertices on a face is not completely
arbitrary:  They should be listed in counterclockwise order as seen from
in front of the face, that is, looking at the face from the outside of the
pyramid.</p>


<p>This pyramid geometry as given will work with a <span class="classname">MeshBasicMaterial</span>,
but to work with lit materials such as <span class="classname">MeshLambertMaterial</span>
or <span class="classname">MeshPhongMaterial</span>, the geometry needs <span class="word" data-term="normal vector" data-definition="A normal vector to a surface at a point on that 
surface is a vector that is perpendicular to the surface at that point.
Normal vectors to curves are defined similarly.  Normal vectors are important
for lighting calculations." title="Click for a definition of normal vector.">normal vectors</span>.
If the geometry has no normal vectors, Lambert and Phong materials will appear black.
It is possible to assign the normal vectors by hand, but you can also have <i>three.js</i> 
compute them for you by calling methods in the geometry class.  For the pyramid,
this would be done by calling</p>


<pre>pyramidGeom.computeFaceNormals();</pre>


<p class="noindent">This method computes one normal vector for each face, where
the normal is perpendicular to the face.   This is sufficient if the
material is using <span class="word" data-term="flat shading" data-definition="A lighting computation for the faces of a polygon or polygonal
mesh that uses the same normal vector at each point in the polygon, giving the polygon a flat
or faceted appearance." title="Click for a definition of flat shading.">flat shading</span>; that is, if the material's <i>flatShading</i>
property is set to <i>true</i>. The <i>flatShading</i> property
was discussed in <a href="../c5/s1.html#threejs.1.3">Subsection&nbsp;5.1.3</a>.</p>


<p>Flat shading is appropriate for the pyramid.
But when an object is supposed to look smooth rather than faceted, it needs a normal
vector for each vertex rather than one for each face.  A <span class="classname">Face3</span> has an array of three
vertex normals.  They can be set by hand, or <i>Three.js</i> can compute
reasonable vertex normals for a smooth surface by averaging the face normals
of all faces that share a vertex.  Just call</p>


<pre>geom.computeVertexNormals();</pre>


<p class="noindent">where <i>geom</i> is the geometry object.
Note that the face normals must already exist before <i>computeVertexNormals</i> is called, 
so that usually you will call <i>geom.computeVertexNormals</i>() immediately after calling
<i>geom.computeFaceNormals</i>().  A geometry that has face normals but not vertex normals
will not work with a material whose <i>flatShading</i> property has the default value,
<i>false</i>.  To make it possible to use <span class="word" data-term="smooth shading" data-definition="A lighting computation for the faces of a polygon or polygonal
mesh that uses a different normal vector at each vertex of the polygon.  When two polygons
share a vertex, both polygons use the same normal vector for that vertex, resulting in a
smooth appearance at that vertex.  Smooth shading is appropriate when a polygonal mesh is
used as an approximation for a smooth surface." title="Click for a definition of smooth shading.">smooth shading</span> on a surface 
like the pyramid, all of the vertex normals of each face should be set equal to its face normal.  In
that case, even with smooth shading, the pyramid's side will look flat.  Standard <i>three.js</i>
geometries such as <span class="classname">BoxGeometry</span> come with correct face and vertex
normals.</p>


<p>The face normal for an object, <i>face</i>, of type <span class="classname">THREE.Face3</span>
is stored in the property <i>face.normal</i>.  The vertex normals are stored in
<i>face.vertexNormals</i>, which is an array of three <span class="classname">Vector3</span>.</p>


<hr class="break">


<p>With a full set of normal vectors, the pyramid is ready to be used with any of the mesh
materials that we have covered, but it looks a little boring with just one color.
It's possible to use several colors on one mesh.  To do that, you can supply an
array of materials to the mesh object constructor, instead of a single material.
This makes it possible to apply
different materials to different faces. For example, here is how to make
a cube with different materials on its six sides:</p>


<pre>var cubeGeom = new THREE.BoxGeometry(10,10,10);
var cubeMaterials =  [
    new THREE.MeshPhongMaterial( { color: "red" } ),     // for the +x face
    new THREE.MeshPhongMaterial( { color: "cyan" } ),    // for the -x face
    new THREE.MeshPhongMaterial( { color: "green" } ),   // for the +y face
    new THREE.MeshPhongMaterial( { color: "magenta" } ), // for the -y face
    new THREE.MeshPhongMaterial( { color: "blue" } ),    // for the +z face
    new THREE.MeshPhongMaterial( { color: "yellow" } )   // for the -z face
];
var cube = new THREE.Mesh( cubeGeom, cubeMaterials );</pre>


<p>For this to work with a geometry, each face
of the geometry needs a "material index."  The material index of a face is an integer
that is an index into the array of  materials.  The faces of a <span class="classname">BoxGeometry</span>
have appropriate indices.  Note that a box geometry has 12 faces, since each rectangular side
is divided into two triangular faces.  The two triangles that make up a rectangular side
have the same material index.  (<span class="classname">BoxGeometry</span> is the only standard
geometry that I can find that comes with non-zero material indices.  The default value
for the material index is zero.)</p>


<p>Suppose that we want to use different materials on each side of the
pyramid that was created above.  For that to work, each face needs a material index,
which is stored in a property of the face named <i>materialIndex</i>.  For the pyramid, the first two 
faces in the array of faces make up the square
base of the pyramid.  They should probably have the same material index.  The following code
assigns material index 0 to the first two faces and material indices 1, 2, 3, and 4 to
the other four faces:</p>


<pre>pyramidGeom.faces[0].materialIndex = 0;
for (var i = 1; i &lt;= 5; i++) {
    pyramidGeom.faces[i].materialIndex = i-1;
}</pre>


<p class="noindent">This code is from the sample program <span class="sourceref"><a href="../source/threejs/MeshFaceMaterial.html">threejs/MeshFaceMaterial.html</a></span>.
The program displays a cube and a pyramid using multiple materials on each object.  Here's what they
look like:</p>


<p align="center">
<img src="MeshFaceMaterial.png" width="508" height="243" alt=""></p>


<hr class="break">


<p>There is another way to assign a different color to each face of a mesh object:  It is possible
to store the colors as properties of the face objects in the geometry.  You can then use an ordinary
material on the object, instead of an array of materials.  But you also have to tell the
material to use the colors from the geometry in place of the material's <i>color</i> property.</p>


<p>There are several ways that color might be assigned to faces in a mesh.  One is to simply
make each face a different solid color.  Each face object has a <i>color</i> property that
can be used to implement this idea.  The value of the <i>color</i> property is an object of type
<span class="classname">THREE.Color</span>, representing a color for the entire face.
For example, we can set the face colors of the pyramid with</p>


<pre>pyramidGeom.faces[0].color = new THREE.Color(0xCCCCCC);
pyramidGeom.faces[1].color = new THREE.Color(0xCCCCCC);
pyramidGeom.faces[2].color = new THREE.Color("green");
pyramidGeom.faces[3].color = new THREE.Color("blue");
pyramidGeom.faces[4].color = new THREE.Color("yellow");
pyramidGeom.faces[5].color = new THREE.Color("red");</pre>


<p class="noindent">To use these colors, the <i>vertexColors</i> property
of the material must be set to the value <i>THREE.FaceColors</i>;
for example:</p>


<pre>material = new THREE.MeshLambertMaterial({
        vertexColors: THREE.FaceColors,
        shading: THREE.FlatShading
    });</pre>


<p class="noindent">The default value of the property is <i>THREE.NoColors</i>, which tells
the renderer to use the material's <i>color</i> property for every face.</p>


<p>A second way to apply color to a face is to apply a different
color to each vertex of the face.  WebGL will then interpolate the vertex colors to compute
colors for pixels inside the face.  Each face object has a property named <i>vertexColors</i>
whose value should be an array of three <span class="classname">THREE.Color</span> objects,
one for each vertex of the face.  To use these colors, the <i>vertexColors</i>
property of the material has to be set to <i>THREE.VertexColors</i>.</p>


<p>The following
demo uses vertex colors and face colors on an icosahedral approximation for a sphere.  The
colors can be animated.  In the color animation, each of the colors that is used on the
object cycles through the set of possible hues.  The positions of the vertices can also be
animated.</p>
<div class="demo">
<noscript>
<h4 style="color:red; text-align:center">Demos require JavaScript.<br>Since JavaScript is not available,<br>the demo is not functional.</h4>
</noscript>
<p align="center">
<iframe src="../demos/c5/vertex-and-color-animation.html" width="590" height="375"></iframe>
</p>
</div>





</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="threejs.2.2">5.2.2&nbsp;&nbsp;Curves and Surfaces</h3>



<p>In addition to letting you build indexed face sets, <i>three.js</i> has support for working
with curves and surfaces that are defined mathematically.  Some of the possibilities are
illustrated in the sample program <span class="sourceref"><a href="../source/threejs/curves-and-surfaces.html">threejs/curves-and-surfaces.html</a></span>, and I will
discuss a few of them here.</p>


<p>Parametric surfaces are the easiest to work with.  A parametric surface is defined by
a mathematical function <i>f</i>(<i>u,v</i>), where <i>u</i> and <i>v</i> are numbers,
and each value of the function is a point in space.  The surface consists of all the points
that are values of the function for <i>u</i> and <i>v</i> in some specified ranges.
For <i>three.js</i>, the function is a regular JavaScript function that returns values of
type <span class="classname">THREE.Vector3</span>.  A parametric surface geometry 
is created by evaluating the function at a grid of <i>uv</i> points.  This gives a
grid of points on the surface, which are then connected to give a polygonal approximation
of the surface.  In <i>three.js</i>, the values of <i>u</i> and <i>v</i> are always in the
range 0.0 to 1.0.  The geometry is created by a constructor</p>


<pre>new THREE.ParametricGeometry( func, slices, stacks )</pre>


<p class="noindent">where <i>func</i> is the JavaScript function and <i>slices</i> and <i>stacks</i> determine
the number of points in the grid; <i>slices</i> gives the number of subdivisions of the
interval from 0 to 1 in the <i>u</i> direction, and <i>stacks</i>, in the <i>v</i> direction.
Once you have the geometry, you can use it to make a mesh in the usual way.  Here is
an example, from the sample program:</p>


<p align="center">
<img src="parametric-surface.png" width="456" height="267" alt=""></p>


<p class="noindent">This surface is defined by the function</p>


<pre>function surfaceFunction( u, v ) {
    var x,y,z;  // A point on the surface, calculated from u,v.
                // u  and v range from 0 to 1.
    x = 20 * (u - 0.5);  // x and z range from -10 to 10
    z = 20 * (v - 0.5);
    y = 2*(Math.sin(x/2) * Math.cos(z));
    return new THREE.Vector3( x, y, z );
}</pre>


<p class="noindent">and the <i>three.js</i> mesh that represents the surface is created using</p>


<pre>var surfaceGeometry = new THREE.ParametricGeometry(surfaceFunction, 64, 64);
var surface = new THREE.Mesh( surfaceGeometry, material );</pre>


<p>Curves are more complicated in <i>three.js</i> (and, unfortunately, the API for working
with curves is not very consistent).  The class <span class="classname">THREE.Curve</span>
represents the abstract idea of a parametric curve in two or three dimensions.  (It does not represent
a <i>three.js</i> geometry.)  A parametric curve is defined by a function of one numeric variable
<i>t</i>.  The value returned by the function is of type <span class="classname">THREE.Vector2</span> for a 2D curve or 
<span class="classname">THREE.Vector3</span> for
a 3D curve.  For an object, <i>curve</i>, of type <span class="classname">THREE.Curve</span>,
the method <i>curve.getPoint</i>(<i>t</i>) should return the point on the curve corresponding
to the value of the parameter <i>t</i>.  However, in the <span class="classname">Curve</span> class
itself, this function is undefined.  To get an actual curve, you have to define it.
For example,</p>


<pre>var helix = new THREE.Curve();
helix.getPoint = function(t) {
   var s = (t - 0.5) * 12*Math.PI;
         // As t ranges from 0 to 1, s ranges from -6*PI to 6*PI
   return new THREE.Vector3(
        5*Math.cos(s),
        s,
        5*Math.sin(s)
   );
}</pre>


<p>Once <i>getPoint</i> is defined, you have a usable curve.  One thing that you can do with
it is create a tube geometry, which defines a surface that is a tube with a circular cross-section
and with the curve running along the center of the tube. The sample program uses the <i>helix</i> 
curve, defined above, to create two tubes:</p>


<p align="center">
<img src="tube-geometry.png" width="264" height="331" alt=""></p>


<p class="noindent">The geometry for the wider tube is created with</p>


<pre>tubeGeometry1 = new THREE.TubeGeometry( helix, 128, 2.5, 32 );</pre>


<p class="noindent">The second parameter to the constructor is the number of subdivisions of the surface along the
length of the curve.  The third is the radius of the circular cross-section of the tube, and the fourth is the
number of subdivisions around the circumference of the cross-section.</p>


<p>To make a tube, you need a 3D curve.  There are also several ways to make a surface from
a 2D curve.  One way is to rotate the curve about a line, generating a surface of rotation.  The surface consists of
all the points that the curve passes through as it rotates.  This is called <span class="newword" data-term="lathing" data-definition="A technique for producing a surface by rotating a planar curve about a line
that lies in the same plane as the curve. As each point rotates about the line, it generates a circle.
The surface is the union of the circles generated by all the points on the curve. Lathing imitates
shapes that can be produced by a mechanical lathe." title="Click for a definition of lathing.">lathing</span>.
This image from the sample program shows the surface generated by lathing a cosine curve.  (The image is
rotated 90 degrees, so that the y-axis is horizontal.)
The curve itself is shown above the surface:</p>


<p align="center">
<img src="lathe-geometry.png" width="370" height="244" alt=""></p>


<p>The surface is created in <i>three.js</i> using a <span class="classname">THREE.LatheGeometry</span>
object.  A <span class="classname">LatheGeometry</span> is constructed not from a curve but from
an array of points that lie on the curve.  The points are objects of type 
<span class="classname">Vector2</span>, and the curve lies in the xy-plane.  The surface is generated by
rotating the curve about the y-axis.  The <span class="classname">LatheGeometry</span> constructor takes the form</p>


<pre>new THREE.LatheGeometry( points, slices )</pre>


<p class="noindent">The first parameter is the array of <span class="classname">Vector2</span>.  The second
is the number of subdivisions of the surface along the circle generated when a point
is rotated about the axis.  (The number
of "stacks" for the surface is given by the length of the points array.)  In the sample
program, I create the array of points from an object, <i>cosine</i>, of type
<span class="classname">Curve</span> by calling <i>cosine.getPoints</i>(128).  This function
creates an array of 128 points on the curve, using values of the parameter that
range from 0.0 to 1.0.</p>


<p>Another thing that you can do with a 2D curve is simply to fill in the inside of the curve, giving a 
2D filled shape.  To do that in <i>three.js</i>, you can use an object of type
<span class="classname">THREE.Shape</span>, which is a subclass of <span class="classname">THREE.Curve</span>.
A <span class="classname">Shape</span> can be defined in the same way as a path in the 
2D Canvas API that was covered in <a href="../c2/s6.html">Section&nbsp;2.6</a>.  That is, an
object <i>shape</i> of type <span class="classname">THREE.Shape</span> has methods
<i>shape.moveTo</i>, <i>shape.lineTo</i>, <i>shape.quadraticCurveTo</i> and <i>shape.bezierCurveTo</i>
that can be used to define the path. See <a href="../c2/s6.html#graphics2d.6.2">Subsection&nbsp;2.6.2</a> for details of how
these functions work.  As an example, we can create a teardrop shape:</p>


<pre>var path = new THREE.Shape();
path.moveTo(0,10);
path.bezierCurveTo( 0,5, 20,-10, 0,-10 );
path.bezierCurveTo( -20,-10, 0,5, 0,10 );</pre>


<p class="noindent">To use the path to create a filled shape in <i>three.js</i>, we need a <span class="classname">ShapeGeometry</span>
object:</p>


<pre>var shapeGeom = new THREE.ShapeGeometry( path );</pre>


<p class="noindent">The 2D shape created with this geometry
is shown on the left in this picture:</p>


<p align="center">
<img src="extrusion-geometry.png" width="412" height="157" alt=""></p>


<p>The other two objects in the picture were created by <span class="newword" data-term="extrusion" data-definition="A technique for producing a solid from a 2D shape by
moving the shape along a curve in 3D.  The solid is the set of points through which
the shape passes as it moves along the curve.  The most common case is moving the shape
along a line segment that is perpendicular to the plane that contains the shape.  In practice,
in computer graphics, the object that is produced by extrusion is just the surface of
the extruded solid." title="Click for a definition of extrusion.">extruding</span>
the shape.  In extrusion, a filled 2D shape is moved along a path in 3D.  The points that the shape
passes through make up a 3D solid.  In this case, the shape was extruded along a line segement
perpendicular to the shape, which is the most common case.  The basic extruded shape is
shown on the right in the illustration.  The middle object is the same shape with "beveled"
edges.  For more details on extrusion, see the documentation for <span class="classname">THREE.ExtrudeGeometry</span>
and the source code for the 
<span class="sourceref"><a href="../source/threejs/curves-and-surfaces.html">sample program</a></span>.</p>


</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="threejs.2.3">5.2.3&nbsp;&nbsp;Textures</h3>


<p>A <span class="word" data-term="texture" data-definition="Variation in some property from point-to-point on an object.  The most common type
is image texture.  When an image texture is applied to a surface, the surface color varies from
point to point." title="Click for a definition of texture.">texture</span> can be used to add visual interest and detail to an object.
In <i>three.js</i>, an image texture is represented by an object of type 
<span class="classname">THREE.Texture</span>.  Since we are talking about web pages, the image
for a <i>three.js</i> texture is generally loaded from a web address.  Image textures are usually created
using the <i>load</i> function in an object of type
<span class="classname">THREE.TextureLoader</span>.  The function takes a
URL (a web address, usually a relative address) as parameter and returns a <span class="classname">Texture</span> object:</p>


<pre>var loader = new THREE.TextureLoader();
var texture = loader.load( imageURL );</pre>


<p class="noindent">A texture in <i>three.js</i> is considered to be part of a material.  To apply
a texture to a mesh, just assign the <span class="classname">Texture</span> object to the
<i>map</i> property of the mesh material that is used on the mesh:
</p>


<pre>material.map = texture;</pre>


<p>The <i>map</i> property can also be set in the material constructor.
All three types of mesh material (Basic, Lambert, and Phong) can use a texture.
In general, the material base color will be white, since the material color will
be multiplied by colors from the texture.  A non-white material color will add
a "tint" to the texture colors.  The <span class="word" data-term="texture coordinates" data-definition="Refers to the 2D coordinate system on a texture image, or to
similar coordinate systems for 1D and 3D textures.  Texture coordinates typically range from 0 to 1
both vertically and horizontally, with (0,0) at the lower left corner of the image.  The
term also refers to coordinates that are given for a surface and that are used to specify
how a texture image should be mapped to the surface." title="Click for a definition of texture coordinates.">texture coordinates</span> that are needed to
map the image to a mesh are part of the mesh
geometry.  The standard mesh geometries such as <span class="classname">THREE.SphereGeometry</span>
come with texture coordinates already defined.</p>


<p>That's the basic idea&mdash;create a texture object from an image URL and assign
it to the <i>map</i> property of a material.  However, there are complications.
First of all, image loading is "asynchronous."  That is, calling
the load function only starts the process of loading the image,
and the process can complete sometime after the function returns.  Using a texture
on an object before the image has finished loading does not cause an error, but
the object will be rendered as completely black.  Once the image
has been loaded, the scene has to be rendered again to show the image texture.
If an animation is running, this will happen automatically; the image will appear
in the first frame after it has finished loading.  But if there is no animation,
you need a way to render the scene once the image has loaded.  In fact, the
<i>load</i> function in a <span class="classname">TextureLoader</span> has several optional parameters:</p>


<pre>loader.load( imageURL, onLoad, undefined, onError );</pre>


<p class="noindent">The third parameter here is given as <i>undefined</i> because
that parameter is no longer used.  The <i>onLoad</i>
and <i>onError</i> parameters are callback functions.  The <i>onLoad</i>
function, if defined, will be called once the image has been successfully loaded.
The <i>onError</i> function will be called if the attempt to load the image
fails.  For example, if there is a function <i>render</i>() that renders the
scene, then <i>render</i> itself could be used as the <i>onLoad</i> function:</p>


<pre>var texture = new THREE.TextureLoader().load( "brick.png", render );</pre>


<p class="noindent">Another possible use of <i>onLoad</i> would be to delay assigning
the texture to a material until the image has finished loading.  If you do
change the value of <i>material.map</i>, be sure to set</p>


<pre>material.needsUpdate = true;</pre>
   

<p class="noindent">to make sure that the change will take effect when the object is redrawn.</p>
    

<p>A <span class="classname">Texture</span> has a number of properties that can be
set, including properties to set the <span class="word" data-term="minification filter" data-definition="An operation that is used when applying a texture to an object,
when the texture has to be shrunk to fit the object.  For an image texture, a minification filter
is applied to compute the color of a pixel when that pixel covers several pixels in the image." title="Click for a definition of minification filter.">minification</span>
and <span class="word" data-term="magnification filter" data-definition="An operation that is used when applying a texture to an object,
when the texture has to be stretched to fit the object.  For an image texture, a magnification filter
is applied to compute the color of a pixel when that pixel covers just a fraction of a pixel in the image." title="Click for a definition of magnification filter.">magnification</span> filters for the
texture and a property to control the generation of <span class="word" data-term="mipmap" data-definition="One of a series of reduced-size copies of a texture image, of decreasing width and height.
Starting from the original image, each mipmap is obtained by dividing the width and height of
the previous image by two (unless it is already 1).  The final mimpap is a single pixel.  Mipmaps
are used for more efficient mapping of the texture image to a surface, when the image has to be
shrunk to fit the surface." title="Click for a definition of mipmap.">mipmaps</span>, which is done automatically
by default.  The properties that you are most likely to want to change are the wrap mode
for texture coordinates outside the range 0 to&nbsp;1 and the <span class="word" data-term="texture transformation" data-definition="A transformation that is applied to texture coordinates before
they are used to sample data from a texture.  The effect is to translate, rotate, or scale the
texture on the surface to which it is applied." title="Click for a definition of texture transformation.">texture transformation</span>.
(See <a href="../c4/s3.html">Section&nbsp;4.3</a> for more information about these properties.)</p>


<p>For a <span class="classname">Texture</span> object <i>tex</i>, the properties <i>tex.wrapS</i> and <i>tex.wrapT</i>
control how <i>s</i> and <i>t</i> texture coordinates outside the range 0 to 1 are
treated.  The default is "clamp to edge."  You will most likely want
to make the texture repeat in both directions by setting the property values to
<i>THREE.RepeatWrapping</i>:
</p>


<pre>tex.wrapS = THREE.RepeatWrapping;
tex.wrapT = THREE.RepeatWrapping;</pre>


<p class="noindent">RepeatWrapping works best with "seamless" textures, where the top edge of the image
matches up with the bottom edge and the left edge with the right.
<i>Three.js</i> also offers an interesting variation called "mirrored
repeat" in which every other copy of the repeated image is flipped.  This eliminates
the seam between copies of the image.  For mirrored repetition, use the property value
<i>THREE.MirroredRepeatWrapping</i>:</p>


<pre>tex.wrapS = THREE.MirroredRepeatWrapping;
tex.wrapT = THREE.MirroredRepeatWrapping;</pre>


<p>The texture properties <i>repeat</i> and <i>offset</i> control the scaling and translation that are applied
to the texture as <span class="word" data-term="texture transformation" data-definition="A transformation that is applied to texture coordinates before
they are used to sample data from a texture.  The effect is to translate, rotate, or scale the
texture on the surface to which it is applied." title="Click for a definition of texture transformation.">texture transformations</span>. (There is no
texture rotation.)  The values of these properties are of type <span class="classname">THREE.Vector2</span>,
so that each property has an <i>x</i> and a <i>y</i> component.  For a <span class="classname">Texture</span>,
<i>tex</i>, the two components of <i>tex.offset</i> give the texture translation in the horizontal
and vertical directions.  To offset the texture by 0.5 horizontally, you can say
either</p>


<pre>tex.offset.x = 0.5;</pre>


<p class="noindent">or</p>


<pre>tex.offset.set( 0.5, 0 );</pre>


<p class="noindent">Remember that a positive horizontal offset will move the
texture to the <i>left</i> on the objects, because the offset is applied to the
texture coordinates not to the texture image itself.</p>


<p>The components of the property <i>tex.repeat</i>
give the texture scaling in the horizontal and vertical directions.  For example,</p>


<pre>tex.repeat.set(2,3);</pre>


<p class="noindent">will scale the texture coordinates by a factor of 2 horizontally and
3 vertically.  Again, the effect on the image is the inverse, so that the image
is shrunk by a factor of 2 horizontally and 3 vertically.  The result is that you
get two copies of the image in the horizontal direction where you would have had
one, and three vertically.  This explains the name "repeat," but note that the values
are not limited to be integers.</p>


<p>This demo lets you
view some textured <i>three.js</i> objects.  The "Pill" object in the demo, by the way,
is a compound object consisting of a cylinder and two hemispheres.
</p>
<div class="demo">
<noscript>
<h4 style="color:red; text-align:center">Demos require JavaScript.<br>Since JavaScript is not available,<br>the demo is not functional.</h4>
</noscript>
<p align="center">
<iframe src="../demos/c5/textures.html" width="575" height="370"></iframe>
</p>
</div>


<hr class="break">


<p>Suppose that we want to use an image texture on the pyramid that was created at the
beginning of this section. In order to apply a texture image to an object, WebGL needs texture coordinates
for that object.  When we build a mesh from scratch, we have to supply the texture
coordinates as part of the mesh's geometry object.</p>


<p>A geometry object such as <i>pyramidGeom</i> in the example has a property
named <i>faceVertexUvs</i> to hold texture coordinates.  ("UV"&nbsp;refers to the
coordinates on an object that are mapped to the <i>s</i> and <i>t</i> coordinates in a texture.)
The value of <i>faceVertexUvs</i> is an array, where each element of the array
is itself an array of arrays; in most cases only the element <i>faceVertexUvs</i>[0]
is used, but additional sets of uv coordinates are used in some advanced applications.
The value of <i>faceVertexUvs</i>[0] is itself an array,
with one element for each face in the geometry.
The data stored for each face is, again, an array: <i>faceVertexUvs</i>[0][<i>N</i>] is
an array containing one pair of coordinates for each of the three vertices of face number&nbsp;<i>N</i>.  
Finally, each pair of texture coordinates
in that array is represented as an object of type <span class="classname">THREE.Vector2</span>.</p>


<p>The pyramid has six triangular faces.  We need an array of three objects of
type <span class="classname">Vector2</span> for each face.  The coordinates have to be chosen
to map the image in a reasonable way onto the faces.  My choice of coordinates
maps the entire texture image onto the square base of the pyramid, and it cuts
a triangle out of the image to apply to each of the sides. It takes some
care to come up with the correct coordinates.  I define the texture
coordinates for the pyramid geometry as follows:</p>


<pre>pyramidGeometry.faceVertexUvs = [[
  [ new THREE.Vector2(0,0), new THREE.Vector2(0,1), new THREE.Vector2(1,1) ],
  [ new THREE.Vector2(0,0), new THREE.Vector2(1,1), new THREE.Vector2(1,0) ],
  [ new THREE.Vector2(0,0), new THREE.Vector2(1,0), new THREE.Vector2(0.5,1) ],
  [ new THREE.Vector2(1,0), new THREE.Vector2(0,0), new THREE.Vector2(0.5,1) ],
  [ new THREE.Vector2(0,0), new THREE.Vector2(1,0), new THREE.Vector2(0.5,1) ],
  [ new THREE.Vector2(1,0), new THREE.Vector2(0,0), new THREE.Vector2(0.5,1) ],
]];</pre>


<p class="noindent">Note that this is a three-dimensional array.</p>


<p>The sample program <span class="sourceref"><a href="../source/threejs/textured-pyramid.html">threejs/textured-pyramid.html</a></span> shows
the pyramid with a brick texture.  Here is an image from the program:</p>


<p align="center">
<img src="textured-pyramid.png" width="300" height="158" alt=""></p>


</div>



<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="threejs.2.4">5.2.4&nbsp;&nbsp;Transforms</h3>


<p>In order to understand how to work with objects effectively in <i>three.js</i>, it can be useful to
know more about how it implements <span class="word" data-term="geometric transform" data-definition="A coordinate transformation; that is, a function that can
be applied to each of the points in a geometric object to produce a new object.  Common
transforms include scaling, rotation, and translation. " title="Click for a definition of geometric transform.">transforms</span>.
I have explained that an <span class="classname">Object3D</span>, <i>obj</i>, has properties
<i>obj.position</i>, <i>obj.scale</i>, and <i>obj.rotation</i> that specify its modeling
transformation in its own local coordinate system.  But these properties are not used
directly when the object is rendered.  Instead, they are combined to compute another
property, <i>obj.matrix</i>, that represents the transformation as a matrix.  By default, this
matrix is recomputed automatically every time the scene is rendered.  This can be inefficient
if the transformation never changes, so <i>obj</i> has another property,
<i>obj.matrixAutoUpdate</i>, that controls whether <i>obj.matrix</i> is computed automatically.
If you set <i>obj.matrixAutoUpdate</i> to <i>false</i>, the update is not done.  In that case,
if you do want to change the modeling transformation, you can call <i>obj.updateMatrix</i>()
to compute the matrix from the current values of <i>obj.position</i>, <i>obj.scale</i>,
and <i>obj.rotation</i>.</p>


<p>We have seen how to modify <i>obj's</i> modeling transformation by directly changing the
values of the properties <i>obj.position</i>, <i>obj.scale</i>, and <i>obj.rotation</i>.
However, you can also change the position by calling the function <i>obj.translateX</i>(<i>dx</i>),
<i>obj.translateY</i>(<i>dy</i>), or <i>obj.translateZ</i>(<i>dz</i>) to move
the object by a specified amount in the direction of a coordinate axis.
There is also a function <i>obj.translateOnAxis</i>(<i>axis,amount</i>),
where <i>axis</i> is a <span class="classname">Vector3</span> and <i>amount</i> is
a number giving the distance to translate the object.  The object is moved
in the direction of the vector, <i>axis</i>.  The vector must be normalized;
that is, it must have length&nbsp;1.  For example, to translate <i>obj</i>
by 5 units in the direction of the vector (1,1,1), you could say</p>


<pre>obj.translateOnAxis( new THREE.Vector3(1,1,1).normalize(), 5 );</pre>


<p>There are no functions for changing the scaling transform.  But
you can change the object's rotation with the functions <i>obj.rotateX</i>(<i>angle</i>), 
<i>obj.rotateY</i>(<i>angle</i>), and <i>obj.rotateZ</i>(<i>angle</i>) to rotate the object 
about the coordinate axes. (Remember that angles are measured in radians.)
Calling <i>obj.rotateX</i>(<i>angle</i>) is not the same as adding <i>angle</i>
onto the value of <i>obj.rotation.x</i>, since it applies a rotation about the x-axis
on top of other rotations that might already have been applied.</p>


<p>There is also a function <i>obj.rotateOnAxis</i>(<i>axis,angle</i>), where <i>axis</i> is a
<span class="classname">Vector3</span>.  This function rotates the object through the
angle <i>angle</i> about the vector (that is, about the line between the origin
and the point given by <i>axis</i>).  The <i>axis</i> must be a normalized vector.</p>


<p>I should emphasize that the translation and rotation functions modify the
<i>position</i> and <i>rotation</i> properties of the object.  That is, they apply
in object coordinates, not world coordinates, and they are applied as the first modeling
transformation on the object when the object is
rendered.  For example, a rotation is
world coordinates can change the position of an object, if it is not positioned
at the origin.  However, changing the value of the <i>rotation</i> property of
an object will never change its position.</p>


<p>(Rotation is actually even more complicated.  The rotation of an object, <i>obj</i>,
is actually represented by the property <i>obj.quaternion</i>, not by the property
<i>obj.rotation</i>.  <span class="newword" data-term="quaternion" data-definition="A vector in the quaternion algebra, which is a four dimensional vector space
in which two vectors, in addition to being added, can be multiplied.  In computer graphics, quaternions of 
length one are often used to represent rotations.  An advantage is that in the quaternion representation,
it is possible to smoothly interpolate between two rotations." title="Click for a definition of quaternion.">Quaternions</span> are mathematical objects
that are often used in computer graphics as an alternative to <span class="word" data-term="Euler angles" data-definition="Express the rotation of an object in its own coordinate system,
given as individual rotations about the x, y, and z axes in that coordinate system.  
The cumulative effect of rotations about the three coordinate axes depends on the order in
which the rotations are applied." title="Click for a definition of Euler angles.">Euler angles</span>,
to represent rotations.  However, when you change one of the properties
<i>obj.rotation</i> or <i>obj.quaterion</i>, the other is automatically updated
to make sure that both properties represent the same rotation.  So, we don't need
to work directly with the quaternions.)</p>


<p>There is one more useful method for setting the rotation:  <i>obj.lookAt</i>(<i>vec</i>),
which rotates the object so that it is facing towards a given point.  
The parameter, <i>vec</i>, is a <span class="classname">Vector3</span>, which must be expressed
in the object's own local coordinate system.  (For an object that has no parent, or whose
ancestors have no modeling transformations, that will be the same as <span class="word" data-term="world coordinates" data-definition="The coordinate system in which a scene is defined.  The image 
that is produced of the scene will show the contents of the world coordinate system that
lie within some some view volume (for 3D) or view window (for 2D).  Objects are defined
in their own object coordinate system. Modeling transformations are then applied to place 
objects into the scene; that is, they transform object coordinates to world coordinates." title="Click for a definition of world coordinates.">world coordinates</span>.)
The object is also rotated so that its "up" direction is equal to the value of the property
<i>obj.up</i>, which by default is (0,1,0).  This function can be used with any object, but it
is most useful for a camera.   
</p>



</div>


<div class="subsection">
<hr class="break">
<h3 class="subsection_title" id="threejs.2.5">5.2.5&nbsp;&nbsp;Loading JSON Models</h3>


<p>Although it is possible to create mesh objects by listing their vertices and faces,
it would be difficult to do it by hand for all but very simple objects.  It's much
easier, for example, to design an object in an interactive modeling program
such as <span class="word" data-term="Blender" data-definition=" A free and open source 3D modeling and animation program." title="Click for a definition of Blender.">Blender</span> (<a href="../a2/index.html">Appendix&nbsp;B</a>).  <i>Three.js</i> has utility functions for loading 
models from files, and it comes with scripts that can be used to
export objects from Blender and other 3D modeling programs to a
file format that <i>three.js</i> can read.  (In the <i>three.js</i> download,
look in the <i>exporters</i> folder inside the <i>utils</i> folder.)</p>


<p>
<i>Three.js</i> has its own file format, in which models are specified
using <span class="word" data-term="JSON" data-definition=" (JavaScript Object Notation.) A syntax for representing JavaScript objects
as strings, similar to the object literal syntax that is used in JavaScript.  JSON objects
cannot contain functions, but they can contain strings, numbers, and booleans.  JSON has
become a popular standard for storage and transmission of structured data." title="Click for a definition of JSON.">JSON</span>, a common format for representing JavaScript objects.
This is the file format that is produced
by the export scripts.  The class <span class="classname">THREE.JSONLoader</span>
can be used to read model descriptions from such files.  There are some
other loaders, which work with other file formats, but I will only discuss 
<span class="classname">JSONLoader</span> here.</p>


<p>If <i>loader</i> is an object of type <span class="classname">THREE.JSONLoader</span>,
you can use its <i>load</i>() method to start the process of loading a model:</p>


<pre>loader.load( url, callback );</pre>


<p class="noindent">The first parameter is a URL for the file that contains the model.
JSON models are stored as actual JavaScript
code, so the file will usually have a name ending in&nbsp;".js".  The second parameter, <i>callback</i>,
is  a function that will be called when the loading is done.  The loading
is asynchronous; <i>loader.load</i>() starts the process and returns immediately.  It is
the responsibility of the callback function to use the data from the file to create a
<i>three.js</i> <span class="classname">Object3D</span> and to add it to the scene.  
The callback function takes two parameters,
<i>geometry</i> and <i>materials</i>, which contain the information needed to create
the object; the parameters represent the data that has been read from the file.
The <i>materials</i> parameter is a material or an array of materials that can be used
as the second parameter in a mesh object constructor. 
(Of course, you could also just use your own material
instead of the material from the file.)</p>


<p>Here, then, is a pair of functions that can be used to load a JSON model
from a specified url and add it to the scene (although in general, you probably
want to do something more complicated with the object):</p>


<pre>function loadModel( url ) {  // Call this function to load the model.
    var loader = new THREE.JSONLoader();
    loader.load( url, modelLoaded ); // Start load, call modelLoaded when done.
}

function modelLoaded( geometry, material ) { // callback function for loader
    var object = new THREE.Mesh( geometry, material );
    scene.add(object);
    render(); // (only need this if there is no animation running)
}</pre>


<p>The sample program <span class="sourceref"><a href="../source/threejs/json-model-viewer.html">threejs/json-model-viewer.html</a></span>
uses <span class="classname">JSONLoader</span> to read model descriptions.  It can display seven
different objects.  I created one of the objects using Blender. The other objects
came with <i>three.js</i>.  Five of the objects use a simple white material;
the "horse" and "stork" use colors that are provided as vertex colors (not materials) in the model file.</p>



<p>I'll also mention that JSON models can define 
simple keyframe animations. To do this,
the file includes alternative sets of vertices for each keyframe (<i>three.js</i> calls them
"morph targets").  <i>Three.js</i> has several classes that support animation, including
<span class="classname">THREE.AnimationMixer</span>, <span class="classname">THREE.AnimationAction</span>,
and <span class="classname">THREE.AnimationClip</span>.   I won't discuss animation here, but these three
classes are used to animate the horse and stork models in this demo:</p>
<div class="demo">
<noscript>
<h4 style="color:red; text-align:center">Demos require JavaScript.<br>Since JavaScript is not available,<br>the demo is not functional.</h4>
</noscript>
<p align="center">
<iframe src="../demos/c5/mesh-animation.html" width="550" height="520"></iframe>
</p>
</div>


</div>




</div>
<hr>
<div align="right">
<small>
        [  <a href="s1.html">Previous Section</a> |
           <a href="s3.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
	    <a href="../index.html">Main Index</a> ]
    </small>
</div>
</div>
</body>
<script src="../resource/glossary.js"></script>
</html>
