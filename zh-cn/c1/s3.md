# 1.3章节

## 硬件和软件

我们将使用OpenGL作为3D图形编程的主要语言。OpenGL的原始版本于1992年由一家名为Silicon Graphics的公司发布，该公司以其图形工作站而闻名 - 这是一款功能强大，价格昂贵的计算机，专为密集型图形应用而设计。（今天，您的智能手机可能拥有更多图形计算能力。）大多数现代计算设备（包括台式计算机，笔记本电脑和许多移动设备）中的图形硬件都支持OpenGL。本节将为您提供有关OpenGL历史和支持它的图形硬件的一些背景知识。

在第一台台式计算机中，屏幕内容由CPU直接管理。例如，要在屏幕上绘制线段，[^CPU]将运行循环以设置沿线的每个像素的颜色。毋庸置疑，图形占用了大量CPU的时间。与我们今天的预期相比，图形性能非常慢。与我们今天的预期相比，图形性能非常慢。那变了什么？当然，计算机的速度要快得多，但最大的变化是在现代计算机中，图形处理是由称为GPU的专用组件完成的。或图形处理单元。GPU包括用于进行图形计算的处理器; 实际上，它可以包括大量并行工作的处理器，以大大加快图形操作。它还包括自己的专用内存，用于存储图像和坐标列表等内容。GPU处理器可以非常快速地访问存储在GPU内存中的数据 - 比访问存储在计算机主内存中的数据要快得多。

要绘制线条或执行其他一些图形操作，CPU只需将命令以及任何必要的数据发送到GPU，GPU负责实际执行这些命令。CPU将大部分图形工作卸载到GPU，经过优化可以非常快速地完成工作。GPU理解的一组命令构成了GPU的API 。OpenGL是图形API的一个示例，大多数GPU支持OpenGL，因为它们可以理解OpenGL命令，或者至少可以将OpenGL命令有效地转换为GPU可以理解的命令。

OpenGL不是唯一的图形API。最着名的替代方案可能是Direct3D，一种用于Microsoft Windows的3D图形API。OpenGL可以更广泛地使用，因为它不仅限于Microsoft，但大多数显卡都支持Direct3D，并且它经常引入早于OpenGL的新功能。

---

我已经说过OpenGL是一个API，但事实上它是一系列的API，经过反复的扩展和修改。目前的版本在2018年初是4.6，与1992年的1.0版本截然不同。此外，还有一个专门用于“嵌入式系统”的OpengGL ES版本，如手机和平板电脑。还有WebGL，用于Web浏览器，它基本上是OpenGL ES 2.0的一个端口。此外，一个名为Vulkan的新API已被定义为OpenGL的替代品; Vulkan是一个复杂的低级API，旨在提高速度和效率，而不是易用性，如果有的话，它可能不会完全取代OpenGL。了解OpenGL如何以及为何发生变化将会很有用。

首先，您应该知道OpenGL被设计为“客户端/服务器”系统。服务器负责控制计算机的显示和执行图形计算，执行客户端发出的命令。通常，服务器是GPU，包括其图形处理器和内存。服务器执行OpenGL命令。客户端是同一台计算机中的CPU，以及它正在运行的应用程序。OpenGL命令来自CPU上运行的程序。但是，实际上可以通过网络远程运行OpenGL程序。也就是说，您可以在远程计算机（OpenGL客户端）上执行应用程序，而图形计算和显示则在您实际使用的计算机上完成（OpenGL服务器）。

关键思想是客户端和服务器是独立的组件，这些组件之间存在通信通道。OpenGL命令及其所需的数据通过该通道从客户端（CPU）传送到服务器（GPU）。通道的容量可能是图形性能的限制因素。考虑将图像绘制到屏幕上。如果GPU可以在几微秒内绘制图像，但是将图像的数据从CPU发送到GPU需要几毫秒，那么GPU的高速度是无关紧要的 - 绘制图像所需的大部分时间是沟通时间。

出于这个原因，OpenGL发展的驱动因素之一是希望限制CPU和GPU之间所需的通信量。一种方法是将信息存储在GPU的内存中。如果一些数据将被多次使用，它可以被传输到GPU一次并存储在那里的存储器中，GPU可以立即访问它。另一种方法是尝试减少必须传输到GPU以绘制给定图像的OpenGL命令的数量。

OpenGL绘制三角形等基元。指定基元意味着为每个顶点指定坐标 和属性。在原始的OpenGL 1.0中，使用单独的命令来指定每个顶点的坐标，并且每次更改属性的值时都需要命令。要绘制单个三角形，需要三个或更多命令。绘制由数千个三角形组成的复杂对象将需要数千个命令。即使在OpenGL 1.1中，也可以使用单个命令而不是数千个来绘制这样的对象。该对象的所有数据都将加载到数组中，然后可以在一个步骤中将其发送到GPU。不幸的是，如果对象不止一次被绘制，那么每次绘制对象时都必须重新传输数据。这在OpenGL 1.5中使用Vertex Buffer Objects进行了修复。VBO是GPU中的一块内存，可以存储一组顶点的坐标或属性值。这使得重用数据成为可能，而无需在每次使用时将其从CPU重新发送到GPU。

类似地，OpenGL 1.1引入了纹理对象 ，使得可以在GPU上存储多个图像以用作纹理。这意味着将要重复使用多次的纹理图像可以一次加载到GPU中，这样GPU就可以轻松地在图像之间切换而无需重新加载它们。

---

随着OpenGL中添加了新功能，API的规模不断扩大。但是，新的更复杂的图形技术的发明仍然超过了增长速度。其中一些新技术被添加到OpenGL中，但问题在于，无论您添加多少功能，总会有新功能的需求 - 以及所有新功能使事情变得太复杂的抱怨！OpenGL是一台巨型机器，新的部件总是贴在它上面，但仍然不能令所有人满意。真正的解决方案是使机器可编程。使用OpenGL 2.0，可以编写要作为GPU中图形计算的一部分执行的程序。程序以GPU速度在GPU上运行。想要使用新图形技术的程序员可以编写程序来实现该功能，并将其交给GPU。不必更改OpenGL API。API必须支持的唯一功能是能够将程序发送到GPU执行。

这些程序被称为着色器（虽然这个术语并没有真正描述它们大多数实际上做了什么）。要引入的第一个着色器是 顶点着色器和片段着色器。当一个原始被绘制时，一些工作已被在原语的每个顶点进行，如施加几何变换到顶点座标或使用属性和全局照明环境来计算该顶点的颜色。顶点着色器是一个程序，可以接管进行这种“每顶点”计算的工作。类似地，必须对基元内的每个像素进行一些工作。片段着色器可以接管执行这种“每像素”计算的工作。（片段着色器也称为像素着色器。）

可编程图形硬件的想法非常成功 - 如此成功，以至于在OpenGL 3.0中，通常的每顶点和每片段处理被弃用（意味着不鼓励使用它）。在OpenGL 3.1中，它已从OpenGL标准中删除，尽管它仍然作为可选扩展存在。实际上，OpenGL的桌面版本仍然支持OpenGL的所有原始功能，并且将来可能会继续提供。但是，在嵌入式系统方面，使用OpenGL ES 2.0及更高版本时，必须使用着色器，并且已完全删除了很大一部分OpenGL 1.1 API。WebGL是用于Web浏览器的OpenGL版本，它基于OpenGL ES 2.0，它还要求着色器完成所有任务。不过，我们将开始使用1.1版对OpenGL进行研究。

OpenGL着色器是用GLSL（OpenGL着色语言）编写的。与OpenGL本身一样，GLSL已经经历了多个版本。我们将在学习GLSL ES 1.0的课程中花一些时间，这是与WebGL 1.0和OpenGL ES 2.0一起使用的版本。GLSL使用类似于C编程语言的语法。

---

作为对GPU硬件的最后评论，我应该注意到为不同顶点完成的计算几乎是独立的，因此可以并行完成。对于不同片段的计算也是如此。事实上，GPU可以有数百或数千个可以并行运行的处理器。不可否认，各个处理器的功能远不如CPU，但是典型的每顶点和每个片段的计算并不是很复杂。大量的处理器以及图形计算中可能存在的大量并行性，即使在相当便宜的GPU上也能实现令人印象深刻的图形性能。


[^CPU]: 计算机中的中央处理单元，即实际执行程序的组件。CPU从计算机内存中读取机器语言指令并执行它们。
